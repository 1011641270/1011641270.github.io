---
layout: default
title: Java 中的垃圾回收策略
---


## 垃圾回收需要解决的问题

* 谁需要被回收
* 什么时候回收
* 怎么回收

## 谁需要被回收

如果一个对象再也不会被用到，就可以回收它了，所以关键在于如何知道一个对象再也不被使用了。

### 引用计数

当一个对象被引用时，引用计数加1，当引用失效时，计数减1。简单直观，但会出现循环引用问题。

```java
a.tb = b
b.ta = a
```

即使 `a` 和 `b` 再也不会被用到了，但他们之间互相引用，导致引用计数一直不为0，无法被回收。

### 可达性分析

Java, C# 的主流实现都是使用可达性分析来判断一个对象是否存活的。如果从 `GC Root` 可以到达一个对象，那么
这个对象是可达的，还存活着，否则就不存活，可以被回收。 `GC Root` 包含以下几类。

* 虚拟机栈引用的对象
* 方法区静态属性引用的对象
* 方法区中常量引用的对象
* 本地方法栈中JNI引用的对象

## 何时及如何回收

何时及如何回收，涉及具体的回收策略，就放一起说了。

### 标记回收算法

最基本的垃圾回收算法，第一次扫描，标记所有可以被回收的对象，第二次扫描，回收被标记的对象。

不足之处

* 效率低
* 会产生内存碎片 

### 复制算法

复制算法将内存分成两部分，每次只使用两部分。假如当前使用的是左半块，右半块没使用。现在要垃圾回收了，
就将左半块还存活的对象复制到右半块。然后将左半块一次性全部回收。

好处是

* 高效
* 没内存碎片


坏处是

* 空间效率低，有半块都不能用


解决方法是，调整左右两块的比例。在 HotSpot 中，内存分成一块 Eden，两块 Survivor，比例是 `8:1`. 每次使用一块 Eden, 一块 Survivor A, 另一块 Survivor B 备用。
垃圾回收时，将 Eden 和 Survivor A 上存活的对象复制到 Survivor B 上，然后将 Eden 和 Survivor A 回收。然后下次使用 Eden, Survivor B,
而 Survivor A 这次备用。

这种方法的前提是每次回收时，大量对象都死掉了，只有一小部分存活着，这样，只复制一小部分就好。但是，如果大量对象存活时间比较长，就要反复来回复制，简直浪费生命。从这一点也可以看出，要根据对象存活时间的特点使用不同的回收策略。

### 标记整理算法

标记整理算法是对标记清除算法的改进。第一次扫描标记需要回收的对象。第二次不是将这些对象清除，而是将还存活的对象移动到内存区域的一端，全他们连在一起。然后对这块区域边界以外的地方全部回收。

### 分代收集算法

从上面的讨论可以看出，要根据对象存活时间使用不同回收策略。有些对象存活时间比较短，这样每次回收时，存活对象少，可以使用复制算法。而有些对象存活时间比较长，这样每次回收时，需要回收的对象少，可以使用标记清除和标记整理算法。
